<style>
  .links line {
    stroke: #ccc;
    opacity: 0.5;
  }

  .nodes circle {
    cursor: pointer;
    fill: #8b88e6;
    transition: all 0.15s ease-out;
  }

  .text text {
    cursor: pointer;
    fill: #333;
    text-shadow: -1px -1px 0 #fafafabb, 1px -1px 0 #fafafabb, -1px 1px 0 #fafafabb, 1px 1px 0 #fafafabb;
  }

  .nodes [active],
  .text [active] {
    cursor: pointer;
    fill: black;
  }

  .inactive {
    opacity: 0.1;
    transition: all 0.15s ease-out;
  }

  #graph-wrapper {
    background: #fcfcfc;
    border-radius: 4px;
    height: auto;
  }
  
  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
    var oScript = document.createElement("script");
    oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
    oScript.crossOrigin = 'anonymous';
    oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
    document.body.appendChild(oScript);
    oScript.onload = () => {
        const GRAPH_DEPTH = 2; // Depth of neighbors to show
        const MINIMAL_NODE_SIZE = 8;
        const MAX_NODE_SIZE = 12;
        const STROKE = 1;
        const FONT_SIZE = 16;
        const TICKS = 200;

        const graphData = {% include notes_graph.json %};
        let allNodes = graphData.nodes;
        let allLinks = graphData.edges;

        // Filter nodes and links to create a local graph
        function getLocalGraph(currentPath, depth = 2) {
            const relevantNodes = new Set();
            const relevantLinks = [];
            
            // Find current node
            const rootNode = allNodes.find((node) => isCurrentPath(node.path));
            if (!rootNode) return { nodes: [], links: [] };

            // BFS to get nodes up to the desired depth
            const queue = [{ node: rootNode, depth: 0 }];
            while (queue.length) {
                const { node, depth: currentDepth } = queue.shift();
                if (currentDepth > depth || relevantNodes.has(node.id)) continue;
                relevantNodes.add(node.id);

                const neighbors = allLinks.filter(
                    (link) => link.source.id === node.id || link.target.id === node.id
                );

                neighbors.forEach((link) => {
                    relevantLinks.push(link);
                    const neighborId = link.source.id === node.id ? link.target.id : link.source.id;
                    const neighborNode = allNodes.find((n) => n.id === neighborId);
                    queue.push({ node: neighborNode, depth: currentDepth + 1 });
                });
            }

            return {
                nodes: allNodes.filter((n) => relevantNodes.has(n.id)),
                links: relevantLinks,
            };
        }

        const { nodes: nodesData, links: linksData } = getLocalGraph(window.location.pathname, GRAPH_DEPTH);

        const svg = d3.select("svg");
        const width = Number(svg.attr("width"));
        const height = Number(svg.attr("height"));

        const simulation = d3
            .forceSimulation(nodesData)
            .force("link", d3.forceLink(linksData).id((d) => d.id).distance(70))
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2))
            .stop();

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");

        const ticked = () => {
            node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
            link
                .attr("x1", (d) => d.source.x)
                .attr("y1", (d) => d.source.y)
                .attr("x2", (d) => d.target.x)
                .attr("y2", (d) => d.target.y);
        };

        simulation.on("tick", ticked);

        node = node
            .data(nodesData)
            .enter()
            .append("circle")
            .attr("r", MINIMAL_NODE_SIZE)
            .on("click", (d) => (window.location = d.path));

        link = link
            .data(linksData)
            .enter()
            .append("line")
            .attr("stroke-width", STROKE);

        simulation.nodes(nodesData).force("link").links(linksData);
        simulation.alpha(1).restart();
    };
}
  </script>
</div>
